# Multi-Hop Reasoning Skill

## 목적
복잡한 질문에 대해 단계적 검색과 추론을 통해 깊이 있는 답변을 도출합니다.

## 핵심 개념

멀티홉 추론은 한 번의 검색으로 답을 얻을 수 없는 복잡한 질문에 대해,
여러 단계의 검색과 추론을 연결하여 최종 답을 찾는 방법입니다.

## 홉 유형 (최대 5회)

| 홉 | 유형 | 설명 | 예시 |
|-----|------|------|------|
| 1 | 엔티티 확장 | 핵심 개념 상세 탐색 | "React" → "React 19 새 기능" |
| 2 | 시간적 진행 | 최신 정보로 업데이트 | "2024 상태" → "2025 변경사항" |
| 3 | 개념적 심화 | 세부 구현/원리 탐색 | "개요" → "내부 동작 원리" |
| 4 | 인과 체인 | 원인-결과 추적 | "문제" → "원인" → "해결책" |
| 5 | 비교/대조 | 대안과 차이점 분석 | "A vs B" → "장단점 비교" |

## 연구 깊이 레벨

| 레벨 | 검색 횟수 | 용도 | 시간 |
|------|----------|------|------|
| Quick | 1-2 | 단순 사실 확인 | ~1분 |
| Standard | 3-4 | 일반 연구 (기본값) | 2-3분 |
| Deep | 5-7 | 기술 분석 | 5-10분 |
| Exhaustive | 8-10 | 종합 보고서 | 15분+ |

## 적응형 쿼리 생성

### 쿼리 정제 전략

```
초기 쿼리: "React 상태 관리"
    ↓
결과 분석: Redux, Zustand, Jotai 언급 발견
    ↓
2차 쿼리: "Redux vs Zustand vs Jotai 2025 비교"
    ↓
결과 분석: 성능 차이 언급, 번들 크기 데이터 부족
    ↓
3차 쿼리: "Zustand bundle size performance benchmark"
```

### 불충분한 결과 처리

| 상황 | 대응 |
|------|------|
| 결과 없음 | 더 일반적인 쿼리로 확장 |
| 오래된 정보 | 연도 추가하여 재검색 |
| 상충되는 정보 | 다른 출처로 교차 검증 |
| 기술적 깊이 부족 | 공식 문서/GitHub 명시 검색 |

## 검색 종료 조건

다음 중 하나 충족 시 검색 종료:

1. **정보 포화**: 새 검색에서 새로운 정보 없음
2. **목표 달성**: 질문에 충분히 답할 수 있음
3. **최대 홉 도달**: 5회 검색 완료
4. **신뢰도 충족**: 0.8 이상 신뢰도 확보

## 쿼리 작성 원칙

### DO
```
# 구체적인 컨텍스트 포함
"FastAPI dependency injection best practices 2025"

# 공식 출처 명시
"Next.js 15 documentation App Router"

# 비교 시 명확한 기준
"Redis vs Memcached latency benchmark production"
```

### DON'T
```
# 너무 광범위
"JavaScript framework"

# 너무 좁음 (결과 없을 가능성)
"React 19.0.1 useOptimistic internal implementation bug"

# 모호한 표현
"best way to do X"
```

## 결과 통합 패턴

```markdown
## 검색 결과 통합

### 홉 1: {초기 쿼리}
- 발견: {핵심 발견}
- 신뢰도: 0.8
- 다음 질문: {파생된 질문}

### 홉 2: {정제된 쿼리}
- 발견: {추가 발견}
- 신뢰도: 0.9
- 이전과 연결: {홉 1 발견과의 관계}

### 종합
- 핵심 결론: {통합된 답변}
- 신뢰도: {가중 평균}
- 불확실 영역: {추가 조사 필요 사항}
```

## 검색 도구 활용

### WebSearch
- 초기 탐색, 최신 정보 수집
- 여러 출처 비교 시 유용

### WebFetch
- 특정 페이지 상세 분석
- 공식 문서, GitHub README 등

### Grep/Read (코드베이스)
- 내부 코드 관련 질문 시
- 기존 구현 확인
